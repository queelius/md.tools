---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

R package: `md.tools`
=====================

<!-- badges: start -->
<!-- badges: end -->

A miscellaneous set of tools for working with *masked data* and common
features of masked data.
The tool set takes inspiration from functional programming, with inputs and
outputs defined over masked data frames of type `tbl_md` (or just data frames),
making it consistent with the *tidyverse* way of doing things.

We provide a set of simple functions on masked data frames, which
may be used to compose more complicated functions, particularly when using
the pipe operator `%>%`.

#### Installation

You can install the development version of `md.tools` from
[GitHub](https://github.com/queelius/md.tools) with:

```{r,eval=F}
# install.packages("devtools")
devtools::install_github("queelius/md.tools")
```

We load the libraries `md.tools` and `tidyverse` with:
```{r,warning=F,message=F}
library(tidyverse)
library(md.tools)
```

## Matrices
A lot of space in `md.tools` is devoted to working with matrices encoded in
the columns of data frames.
We could directly store matrices in a column, but we prefer to work with columns
defined over primitive types like `boolean`.

Consider the `boolean` matrix `C` of size `10`-by-`3`:
```{r}
n <- 5
m <- 3
C <- matrix(sample(c(T,F), size=m*n, replace=TRUE), nrow=n)
```

We may represent this in a data frame of `r n` rows with the columns `c1`,
`c2`, and `c3` with:
```{r}
md <- md_encode_matrix(C,"c")
print(md)
```

We may also decode a matrix stored in a data frame with:
```{r}
print(all(C == md_decode_matrix(md,"c")))
```

We may want to work with a Boolean matrix as a list.
The function `md_boolean_matrix_to_list` uses the following transformation:

  If we have a $n$-by-$m$ Boolean matrix, then if
  the $(j,k)$-element is `TRUE`, the $j$-th vector in the
  list contains the integer $k$.

For instance, suppose we wish to show `md` with a candidate set
as a "set" of integers:
```{r}
as.data.frame(md %>% dplyr::select(-starts_with("c")) %>%
  mutate("candidates"=lapply(
    md_boolean_matrix_to_list(C),
    function(x) { paste0("{",toString(x),"}") })))
```

For completion, we allow converting between these two representations.
Thus, the inverse of `md_boolean_matrix_to_list` is just
`md_list_to_boolean_matrix`.

## Decorators
We now consider some data frame transformations that adds
additional columns with information that may be
inferred from what is already in the data frame.
For this reason, we have chosen to call them *decorators*.

In a masked data frame, we may have a column `k` 
that stores the failed component.
We simulate failed components and mark them
as *latent* with:
```{r}
md <- md %>%
  mutate(k=sample(1:m,n,replace=TRUE)) %>%
  md_mark_latent("k")
print(md)
```

We may additionally have a candidate set encoded by
the Boolean columns `c1`,...,`cm`, in which case
we may infer whether the candidate set *contains*
the failed component `k` with:

```{r}
md$k <- sample(1:m,n,replace=TRUE)
md <- md %>% md_cand_contains("c")
print(md)
```

We see that there is a new column, `contains`, that
tells us whether the candidate set actually contains
the failed component.
No new information is given by this column, it only
presents what information that is already there in
a potentially more conventient format.

Given the same data frame and candidate set, we may
determine the *cardinality* of the candidate sets with:
```{r}
md <- md %>% md_cand_sizes("c")
print(md)
```

We may *unmark* a column variable as latent with:
```{r}
md <- md %>% md.tools::md_unmark_latent("k")
print(md)
```

The latent variable specification is metadata about
the masked data frame, but it does not necessarily
impose any requirements on algorithms applied to it.

More generally, a masked data frame may have a lot
more metadata about it, and we provide some tools
for working with them.
However, for the most part, you are expected to
handle the metadata yourself.
The metadata is stored in the *attributes*, and so
underneath the hood, a masked data frame is just
a data frame and may be treated as one.

## Metadata
To read and write data frames for sharing with others,
including yourself, we prefer to work with plaintext
files like CSV files, where each row corresponds to
some set of measurements of some experimental unit.

However, we may also want to store *metadata* about the experiment that
generated the data, or we may wish to store more information about the
experimental units that does not naturally fit into the data frame model.

To store metadata, we take the general approach of storing JSON (Javscript
Object Notation) in the *comments* of the tabular data file (like CSV), where
a comment by default is anything after the `#` character on a line.

```{r}
data <- md_read_csv_with_meta("./data-raw/exp_series_md_1.csv")
print(data)
```

We may view all of the metadata stored in `data`, minus the `row.names`, with:
```{r}
attr(data,"row.names") <- NULL
print(attributes(data))
```

A lot of the metadata for `data` has to do with how the data was generated.
In particular, we see this data is the result of a simulation
for a series system with 3 exponentially distributed component lifetimes
parameterized by $\lambda = (3,4,5)'$ and a candidate model consistent
with conditions $C_1$, $C_2$, and $C_3$ for series systems with a masked
component cause of failure in the form of candidate sets.
